# 코딩 테스트를 위한 시간 복잡도 핵심 정리
코딩 테스트 문제를 풀 때 "어떻게 풀어야 할까?" 만큼이나 중요한 것이 "이 풀이가 시간 안에 돌아갈까?"를 고민하는 것이다. 

이 '시간'의 효율성을 나타내는 척도가 바로 **시간 복잡도(Time Complexity)**다.

## 빅오(Big-O) 표기법 간단히 이해하기
빅오 표기법은 알고리즘의 최악의 경우 실행 시간이 입력 데이터의 크기(N)에 따라 어떻게 변하는지를 나타내는 방법이다. 핵심은 두 가지만 기억하면 된다.

가장 큰 영향력만 본다: N² + 2N + 3 이라는 연산량이 있다면, N이 커질수록 N²의 영향력이 압도적이므로 O(N²)로 표기한다.

상수는 무시한다: O(2N)이나 O(3N)이나 N이 커지면 결국 N에 비례하므로 둘 다 똑같이 O(N)으로 표기한다.

## 자주 만나는 시간 복잡도 (빠른 순서)
코딩 테스트에서는 보통 N의 크기에 따라 허용되는 시간 복잡도가 정해져 있다. (예: N이 100만이면 O(N)이나 O(N log N) 풀이를, N이 2,000이면 O(N²) 풀이를 떠올려야 한다.)

### O(1) - 상수 시간 (Constant Time)
⚡️ 입력 데이터 N의 크기와 상관없이 언제나 일정한 시간이 걸리는, 가장 빠른 유형이다.

비유: 책이 100쪽이든 10,000쪽이든 상관없이 책의 첫 페이지를 펴는 것과 같다.

주요 예시:

배열의 특정 인덱스에 접근: arr[5]

HashMap의 get(), put() 연산 (평균)

Stack의 push(), pop()

### O(log N) - 로그 시간 (Logarithmic Time)
🌲 N이 2배로 늘어나도, 연산은 딱 한 번만 추가된다. N이 아무리 커져도 연산량은 크게 늘지 않는, 매우 효율적인 유형이다.

비유: 두꺼운 사전에서 단어를 찾을 때, 가운데를 펼쳐보고 찾을 단어가 앞쪽에 있는지 뒤쪽에 있는지 판단해서 절반을 버리는 과정을 반복하는 것과 같다. 매번 탐색 대상이 절반으로 줄어든다.

주요 예시:

이진 탐색 (Binary Search)

균형 잡힌 이진 탐색 트리(BST)에서의 원소 탐색, 추가, 삭제

### O(N) - 선형 시간 (Linear Time)
🚶‍♂️N의 크기만큼 연산량도 정직하게 비례하여 늘어난다.

비유: 100쪽짜리 책을 처음부터 끝까지 한 페이지씩 모두 읽는 것과 같다. 책이 2배 두꺼워지면 읽는 시간도 정확히 2배가 된다.

주요 예시:

for 문으로 배열/리스트를 한 번 순회하는 경우

연결 리스트(Linked List)에서 특정 값 찾기

### O(N log N) - 로그 선형 시간 (Log-Linear Time)
🚀 대부분의 효율적인 정렬 알고리즘이 여기에 속한다. N개의 데이터에 대해 log N 수준의 연산을 반복한다고 이해할 수 있다.

비유: 수백 장의 시험 답안지를 정렬할 때, 일단 절반으로 나눈 뒤(log N의 개념), 각각을 정렬하고 나중에 합치는(N의 개념) 과정을 반복하는 '분할 정복(Divide and Conquer)' 방식과 비슷하다.

주요 예시:

병합 정렬 (Merge Sort)

퀵 정렬 (Quick Sort)의 평균적인 경우

힙 정렬 (Heap Sort)

Java의 Arrays.sort(), Collections.sort()

### O(N²) - 이차 시간 (Quadratic Time)
🐢 N이 커질수록 연산량이 기하급수적으로 늘어나기 때문에, N이 5,000 이상만 되어도 사용하기 힘든 유형이다.

비유: 100명의 사람이 모여서, 모든 사람이 나머지 99명과 한 번씩 빠짐없이 악수하는 것과 같다. 사람이 2배로 늘면 악수 횟수는 약 4배가 된다.

주요 예시:

이중 for 문으로 배열/리스트를 순회 (for (i=0..N) { for (j=0..N) { ... } })

버블 정렬, 선택 정렬, 삽입 정렬

### O(2ⁿ) - 지수 시간 (Exponential Time)
💣 N이 20~30만 넘어가도 현대 컴퓨터로 풀기 어려운, 가장 느린 유형이다. 최후의 수단으로 사용하는 완전 탐색(Brute-force) 기법에서 종종 나타난다.

비유: N개의 전구가 있을 때, 각 전구를 켜거나 끄는 모든 경우의 수를 하나씩 다 확인해보는 것과 같다. 전구가 하나 늘 때마다 확인해야 할 경우의 수가 2배가 된다.

주요 예시:

재귀로 구현한 피보나치 수열

모든 부분 집합(Power Set) 구하기

## 시간 복잡도 간단 요약
| 빅오(Big-O) | 이름 (Name) | 성능 | 주요 예시 |
| :--- | :--- | :--: | :--- |
| `O(1)` | 상수 | 🚀 최상 | 배열 인덱스 접근, HashMap get/put |
| `O(log N)` | 로그 | 👍 매우 좋음 | 이진 탐색 (Binary Search) |
| `O(N)` | 선형 | 🙂 좋음 | for 반복문, 선형 탐색 |
| `O(N log N)`| 로그 선형 | 🤔 괜찮음 | 대부분의 정렬 (병합/퀵 정렬), `Arrays.sort()` |
| `O(N²)` | 이차 | ⚠️ 느림 | 이중 for 반복문, 비효율적인 정렬 (버블/선택 정렬) |
| `O(2ⁿ)` | 지수 | 💣 매우 느림 | 피보나치 재귀, 모든 부분 집합 구하기 |

## 정리하며
문제의 제한 사항에서 N의 최대 크기를 확인하고, 그에 맞는 시간 복잡도를 가진 알고리즘을 설계하는 것이 코딩 테스트의 첫걸음이다. 위 표를 기준으로 "이 N 값에는 최소한 O(N log N)은 써야겠구나!"라고 판단하는 습관을 들이는 것이 중요하다.