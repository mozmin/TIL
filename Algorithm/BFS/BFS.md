# BFS
## 📚 기본 BFS 핵심 개념

BFS도 종류가 여러가지이다. 확실하게 차이점을 알아두자

### 💡 1. 기본 BFS (Breadth-First Search)
핵심 아이디어: 시작점에서 가까운 노드부터 '넓이 우선'으로 탐색합니다. 마치 수면에 돌을 던졌을 때 퍼져나가는 파문과 같습니다.

사용 자료구조: 큐(Queue) (FIFO: First-In, First-Out).

<br>

- 특징

모든 간선의 가중치가 동일할 때 (보통 가중치 1) 최단 경로(최소 이동 횟수)를 보장합니다.

그래프의 모든 노드를 한 번씩 방문하고, 각 간선을 한 번씩 검사하므로 시간 복잡도는 O(V + E) 입니다. (V: 정점 수, E: 간선 수)

visited 배열/Set을 사용하여 중복 방문 및 무한 루프를 방지하는 것이 필수적입니다. (visited에 추가되는 순간 그 노드까지의 최단 경로가 확정됩니다.)

사용 예시: 미로 찾기 (최단 거리), 특정 노드 도달 가능성 여부, 퍼즐 게임 (최소 움직임).

<br>

### 💡 2. 0-1 BFS (Zero-One Breadth-First Search)
핵심 아이디어: 간선 가중치가 0 또는 1인 특별한 경우에, 일반 BFS의 아이디어를 확장하여 다익스트라처럼 최단 경로를 찾습니다.

사용 자료구조: 덱(Deque) (양방향 큐).

<br>

- 동작 방식

시작점까지의 거리는 0, 나머지 노드는 무한대로 초기화합니다.

덱에서 노드를 꺼낼 때, 해당 노드를 거쳐 갈 수 있는 다음 노드들을 탐색합니다.

0비용 간선: 다음 노드를 덱의 **앞(addFirst 또는 offerFirst)**에 추가합니다. (가장 우선순위가 높으므로 즉시 처리)

1비용 간선: 다음 노드를 덱의 **뒤(addLast 또는 offerLast)**에 추가합니다. (조금 더 나중에 처리)

이 규칙 덕분에 덱 안의 노드들은 항상 (거의) 거리 순으로 정렬된 상태를 유지합니다.

<br>

- 특징

덱의 맨 앞에서 노드를 꺼내는 순간, 그 노드까지의 최단 거리(최소 비용)가 확정됩니다.

visited 배열/Set (또는 dp 배열)을 사용하여 중복 방문 및 무한 루프를 방지합니다. (dp[node]가 더 작은 값으로 갱신될 때만 덱에 추가)

시간 복잡도는 O(V + E) 로, 일반 BFS와 동일하게 효율적입니다.

사용 예시: 비용이 0이거나 1인 특정 유형의 이동이 섞여 있는 최단 거리 문제 (예: 순간이동과 걷기).

---
## BFS 응용
### 💡 1. 다익스트라 (Dijkstra) 알고리즘 (Greedy + BFS)
핵심 아이디어: "지금까지 발견된 경로 중 가장 짧은 경로가 곧 최단 경로일 것이다"라는 탐욕적(Greedy) 방식으로 최단 경로를 찾습니다. 모든 간선 가중치가 음수가 아닌 양수여야 합니다.

사용 자료구조: 우선순위 큐(Priority Queue). (항상 가장 비용이 적은 노드를 먼저 꺼냅니다.)

<br>

- 동작 방식

시작점까지의 거리는 0, 나머지 노드는 무한대로 초기화합니다.

우선순위 큐에서 가장 거리가 짧은 노드를 꺼냅니다.

해당 노드를 꺼내는 순간, 그 노드까지의 최단 거리가 확정됩니다.

꺼낸 노드에서 연결된 모든 간선들을 검사하여, 해당 간선을 거쳐 가는 것이 다음 노드까지의 거리를 더 줄일 수 있는지 확인하고 갱신(Relaxation)합니다.

갱신된 노드는 우선순위 큐에 추가(또는 업데이트)합니다.

<br>

- 특징

모든 간선 가중치가 음수가 아니어야 합니다. 음수 가중치가 있으면 최단 경로를 잘못 계산할 수 있습니다.

visited 배열/Set (또는 dp 배열)을 통해 최단 거리가 확정된 노드는 다시 처리하지 않습니다.

시간 복잡도는 보통 O(E log V) (우선순위 큐 사용 시) 또는 O(V^2) (배열에서 최소값 직접 찾을 시).

사용 예시: 내비게이션 최단 경로, 네트워크 라우팅 프로토콜.

<br>

### 💡 2. 벨만-포드 (Bellman-Ford) 알고리즘 (DP + BFS)
핵심 아이디어: 다익스트라가 처리하지 못하는 음수 가중치 간선이 있는 그래프에서도 최단 경로를 찾습니다. **동적 계획법(Dynamic Programming)** 방식을 사용합니다.

사용 자료구조: 특별한 큐/덱은 필요 없고, 단순히 거리 배열(dp)과 간선 리스트만 있으면 됩니다.

<br>

- 동작 방식

시작점까지의 거리는 0, 나머지 노드는 무한대로 초기화합니다.
모든 간선을 V-1번 반복하여 검사하고 거리(Relaxation)를 갱신합니다. (V-1번 반복하는 이유는, 최단 경로는 최대 V-1개의 간선을 가질 수 있기 때문입니다.)

V-1번 반복 후, 한 번 더 모든 간선을 검사했을 때 거리가 또 갱신되는 노드가 있다면, 이는 **음수 사이클(Negative Cycle)**이 존재한다는 것을 의미합니다. 음수 사이클이 있으면 최단 경로가 무한히 작아질 수 있습니다.



- 특징
1. 음수 가중치 간선 처리 가능.
2. 음수 사이클 존재 여부 감지 가능.
3. 시간 복잡도는 O(V * E) 로, 다익스트라보다 느립니다.
4. 사용 예시: 음수 가중치 간선이 포함된 네트워크 분석, 금융 거래 모델링.

### 🔑 핵심 용어 정리
최단 경로(Shortest Path): 특정 시작점에서 다른 모든 노드까지의 최소 비용(또는 최소 이동 횟수)으로 도달하는 경로.

가중치(Weight): 간선을 이동하는 데 드는 비용.

양수 가중치: 다익스트라, 0-1 BFS

음수 가중치: 벨만-포드, SPFA

모든 간선 가중치 동일: 일반 BFS

Relaxation (갱신): 간선 (u → v)를 통해 v까지 가는 거리가 u까지의 거리 + (u→v) 간선 가중치 보다 더 짧은 경우 v까지의 거리를 업데이트하는 과정. dist[v] = min(dist[v], dist[u] + weight(u,v))

visited 배열/Set: 이미 탐색했거나, 최단 거리가 확정된 노드를 표시하여 중복 탐색 및 무한 루프를 방지하고 탐색 효율성을 높이는 장치. BFS/다익스트라에서 필수적.

음수 사이클(Negative Cycle): 간선 가중치의 합이 음수인 순환 경로. 벨만-포드는 이를 감지할 수 있습니다.

그리디(Greedy): 매 순간 최적의 선택을 하는 방식 (예: 다익스트라).

동적 계획법(Dynamic Programming, DP): 문제를 작은 하위 문제로 나누어 해결하고 결과를 저장하여 재활용하는 방식 (예: 벨만-포드).